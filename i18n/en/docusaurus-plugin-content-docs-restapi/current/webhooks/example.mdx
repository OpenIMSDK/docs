---

sidebar_position: 2
title: Callback Example
hide_title: true
---

### **Brief Description**

Implement a customer service chatbot's Q&A functionality using callbacks. This example demonstrates sending a message（Supports sending text messages and picture messages） to the chatbot and having it return the same message.

### Step One: Modify the Configuration File
Modify the config/config.yaml file in open-im-server as per the following template:

![PC Web Interface](./assets/config.png)

Tips:
> url is the callback URL.

> Enable afterSendSingleMsg by setting it to true.

### Step Two: Create a Customer Service Account and Get Admin Token
After successfully deploying **openIM**, register an openIM account and designate it as the customer service chatbot account. Record its **userID** as **robotics**.
Use **Postman** or another API testing tool to call the **http://xx.xx.xx.xx:10009/account/login** interface and note down the returned **imToken**.

### Step Three: Write the **afterSendSingleMsg** Interface
Here's an example:

```Go
func (m *MessageApi) CallbackExample(c *gin.Context) {
	// 1. Callback after sending a single chat message
	var req callbackstruct.CallbackAfterSendSingleMsgReq

	if err := c.BindJSON(&req); err != nil {
		log.ZError(c, "CallbackExample BindJSON failed", err)
		apiresp.GinError(c, errs.ErrArgs.WithDetail(err.Error()).Wrap())
		return
	}

	resp := callbackstruct.CallbackAfterSendSingleMsgResp{
		CommonCallbackResp: callbackstruct.CommonCallbackResp{
			ActionCode: 0,
			ErrCode:    200,
			ErrMsg:     "success",
			ErrDlt:     "successful",
			NextCode:   0,
		},
	}
	c.JSON(http.StatusOK, resp)

	// 2. If the user receiving the message is a customer service bot, return the message.

	// UserID of the robot account
	robotics := "5078764102"
	// Administrator token
	imtoken := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VySUQiOiJpbUFkbWluIiwiUGxhdGZvcm1JRCI6MTAsImV4cCI6MTcxMzI1MjI0OSwibmJmIjoxNzA1NDc1OTQ5LCJpYXQiOjE3MDU0NzYyNDl9.Zi-uFre8zq6msT3mFOumgcfNKBJ92kTw9ewsKeRVbZ4"
	if req.SendID == robotics {
		return
	}
	// Processing text messages
	if req.ContentType == constant.Picture || req.ContentType == constant.Text {
		user, err := m.userRpcClient.GetUserInfo(c, robotics)
		if err != nil {
			log.ZError(c, "CallbackExample get Sender failed", err)
			apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
			return
		}

		// Handle message structures
		text := apistruct.TextElem{}
		picture := apistruct.PictureElem{}
		mapStruct := make(map[string]any)
		if req.ContentType == constant.Text {
			err = json.Unmarshal([]byte(req.Content), &text)
			if err != nil {
				log.ZError(c, "CallbackExample unmarshal failed", err)
				apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
				return
			}
			log.ZDebug(c, "callback", "text", text)
			mapStruct["content"] = text.Content
		} else {
			err = json.Unmarshal([]byte(req.Content), &picture)
			if err != nil {
				log.ZError(c, "CallbackExample unmarshal failed", err)
				apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
				return
			}
			log.ZDebug(c, "callback", "text", picture)
			if strings.Contains(picture.SourcePicture.Type, "/") {
				arr := strings.Split(picture.SourcePicture.Type, "/")
				picture.SourcePicture.Type = arr[1]
			}

			if strings.Contains(picture.BigPicture.Type, "/") {
				arr := strings.Split(picture.BigPicture.Type, "/")
				picture.BigPicture.Type = arr[1]
			}

			if len(picture.SnapshotPicture.Type) == 0 {
				picture.SnapshotPicture.Type = picture.SourcePicture.Type
			}

			mapStructSnap, err := convertStructToMap(picture.SnapshotPicture)
			if err != nil {
				log.ZError(c, "CallbackExample struct to map failed", err)
				apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
				return
			}
			mapStruct["snapshotPicture"] = mapStructSnap

			mapStructBig, err := convertStructToMap(picture.BigPicture)
			if err != nil {
				log.ZError(c, "CallbackExample struct to map failed", err)
				apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
				return
			}
			mapStruct["bigPicture"] = mapStructBig

			mapStructSource, err := convertStructToMap(picture.SourcePicture)
			if err != nil {
				log.ZError(c, "CallbackExample struct to map failed", err)
				apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
				return
			}
			mapStruct["sourcePicture"] = mapStructSource
			mapStruct["sourcePath"] = picture.SourcePath
		}

		log.ZDebug(c, "callback", "mapStruct", mapStruct)

		input := &apistruct.SendMsgReq{
			RecvID: req.SendID,
			SendMsg: apistruct.SendMsg{
				SendID:           user.UserID,
				SenderNickname:   user.Nickname,
				SenderFaceURL:    user.FaceURL,
				SenderPlatformID: req.SenderPlatformID,
				Content:          mapStruct,
				ContentType:      req.ContentType,
				SessionType:      req.SessionType,
				SendTime:         utils.GetCurrentTimestampByMill(), // millisecond
			},
		}

		url := "http://127.0.0.1:10002/msg/send_msg"
		header := make(map[string]string, 2)
		header["token"] = imtoken
		type sendResp struct {
			ErrCode int               `json:"errCode"`
			ErrMsg  string            `json:"errMsg"`
			ErrDlt  string            `json:"errDlt"`
			Data    pbmsg.SendMsgResp `json:"data,omitempty"`
		}

		output := &sendResp{}

		// Initiate a post request that calls the interface that sends the message (the bot sends a message to user)
		b, err := http2.Post(c, url, header, input, 10)
		if err != nil {
			log.ZError(c, "CallbackExample send message failed", err)
			apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
			return
		}
		if err = json.Unmarshal(b, output); err != nil {
			log.ZError(c, "CallbackExample unmarshal failed", err)
			apiresp.GinError(c, errs.ErrInternalServer.WithDetail(err.Error()).Wrap())
			return
		}
		res := &msg.SendMsgResp{
			ServerMsgID: output.Data.ServerMsgID,
			ClientMsgID: output.Data.ClientMsgID,
			SendTime:    output.Data.SendTime,
		}

		apiresp.GinSuccess(c, res)
	}
}

// struct to map
func convertStructToMap(input interface{}) (map[string]interface{}, error) {
	result := make(map[string]interface{})
	inputType := reflect.TypeOf(input)

	inputValue := reflect.ValueOf(input)

	if inputType.Kind() != reflect.Struct {
		return nil, errs.ErrArgs.Wrap("Input is not a struct")
	}

	for i := 0; i < inputType.NumField(); i++ {
		field := inputType.Field(i)
		fieldValue := inputValue.Field(i)

		mapKey := field.Tag.Get("mapstructure")
		fmt.Println(mapKey)

		if mapKey == "" {
			mapKey = field.Name
		}

		mapKey = strings.ToLower(mapKey)

		result[mapKey] = fieldValue.Interface()
	}

	return result, nil
}
```
Tips:
>1. Replace **robotics** in the example with the **robotics** obtained in Step Two.

>2. Replace **imToken** in the example with the **imToken** obtained in Step Two.

>3. Replace **url** in the example with the real **url**.

### Step Four: Experience the Functionality
1. Search for the customer service chatbot account directly through the userID, then send a message to the chatbot.

![PC Web Interface](./assets/sendMessage.png)

2. After the chatbot receives the message, it returns the same message.

![PC Web Interface](./assets/result.png)